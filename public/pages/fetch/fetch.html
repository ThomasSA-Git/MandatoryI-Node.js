    <main class="content">
      <hr />
      <h1>Fetch</h1>
      <hr />

      <p>
        In JavaScript fetch is a function used to make network requests to
        retrieve data from an URL. It is typically used for fetching data from a
        web server. It returns a promise that resolves to a response mathcing
        the response to the request. This makes it possible to work with data
        from the server. A promise is used in asynchronous operations. It
        represents a value that is yet to be resolved or rejected. It is
        resolved when the operation is successful and rejected when it
        encounters an error.
      </p>
      <br />
      <p>Below is in example of a simple fetch without error handling.</p>
      <pre class="pre">
            <code class="javascript">
                fetch("yourURL")
                .then((response) => respone.json())
                .then((result) => {
                    // Handle result of fetch here.
                })
            </code>
        </pre>
      <p>
        The raw response from a fetch is a byte stream and needs to be parsed
        into a format that can be handled. In the example it is handled with
        json() which makes it possible to handle it as a json object. The
        .then() allows us to handle it. In this case firstly by parsing it to a
        json object and secondly handling that object however necessary.
        <br />
        In the example below there is some added error handling. If the request
        is rejected for some reason the an error in thrown. Lastly the error is
        "catched" and is the error message is logged to the console.
      </p>
      <pre class="pre">
            <code class="javascript">
                fetch("yourURL")
                .then(((response) => {
                    if(!response.ok){
                        throw new Error("Error getting data");
                    }
                    return respone.json();
                }))
                then((result) => {
                    // Handle result of fetch here.
                })
                .catch(error => {
                    console.error('There was a problem with the fetch operation:', error);
                  });
            </code>
        </pre>
      <p>
        Depending on what kind of request you're sending the fetch might need a
        path varialbe or a set the method specifically and set the header to
        specify the format of the content of the request (if any). If data needs
        to be sent with the request (needed for POST and PATCH) it needs to be
        added to the body.
        <br />
        Below you can see an example of both a GET with pathvariable and POST
        request from my project. Method and header is set as decribed above, and
        body is also added to be sent with the POST request. To keep the
        snippets short some of the code that is irrelevant for the example has
        been removed.
      </p>
      <pre class="pre">
        <code class="javascript">

          // GET request with added pathvariable from project.
          fetch(`/movies/${getMovieName}`)
          .then((response) => {
              if (!response.ok) {
                  throw new Error("Error getting movie");
          }
                  return response.json();
          })
          .then((result) => {

          });

          // POST request from project.
          fetch(`/movies`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(movieData),
          })
            .then((response) => {
              if (!response.ok) {
                throw new Error("Error posting movie");
              }
              return response.json();
            })
            .then((result) => {
         
            });
        </code>
      </pre>
      <p>
        You can use async/await with the fetch function to make asynchronous
        requests in a more synchronous and readable manner. Using async/await
        makes your code appear more sequential and easier to read. Using
        async/await doesn't change the behavior of the fetch request. It still
        performs the request asynchronously. It just simplifies the code
        structure and makes it look more like synchronous code which can be
        easier to read and maintain.
        <br />
        Since we haven't discussed this in class I won't be going to much into
        detail with this with examples.
      </p>
    </main>
    <script src="../../assets/js/hightLight.js"></script>
  </body>
</html>
